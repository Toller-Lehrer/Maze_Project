مرتضی حیدری:
درسنامه شماره (۱)

در زبان C++، استفاده از #define برای تعریف ماکروها (macros) یک روش قدیمی و متداول است که به شما امکان می‌دهد مقادیر ثابت یا عبارات را با نام‌های توصیفی جایگزین کنید. در مثال شما، #define X_0 76 به این معنی است که هر بار که در کد از X_0 استفاده شود، پیش‌پردازنده (preprocessor) آن را با عدد 76 جایگزین می‌کند.

▎اهداف و مزایای استفاده از #define در C++:

1. خوانایی کد: استفاده از نام‌های توصیفی مانند X_0 به جای اعداد سخت (magic numbers) کمک می‌کند تا کد خواناتر و قابل فهم‌تر باشد. دیگر برنامه‌نویسان (یا خود شما در آینده) بهتر می‌توانند بفهمند که این عدد چه معنایی دارد.

2. سهولت در تغییر: اگر بخواهید مقدار X_0 را تغییر دهید، کافی است فقط در یک مکان آن را تغییر دهید. این کار باعث کاهش احتمال خطا و افزایش نگهداری کد می‌شود.

3. عدم نیاز به تخصیص حافظه: ماکروها در زمان پیش‌پردازش (preprocessing) پردازش می‌شوند و نیازی به تخصیص حافظه ندارند.

4. تعریف شرایط پیش‌پردازشی: می‌توانید از ماکروها برای کنترل شرایط پیش‌پردازشی (مثل شامل کردن یا نکردن بخش‌هایی از کد) استفاده کنید.

▎مثال:

#include <iostream>

#define X_0 76

int main() {
    std::cout << "Value of X_0 is: " << X_0 << std::endl;
    return 0;
}


خروجی این برنامه:
Value of X_0 is: 76


▎نکته:

در C++، به جای استفاده از #define برای تعریف ثابت‌ها، معمولاً بهتر است از const یا constexpr استفاده کنید. این کار به شما امکان می‌دهد نوع داده را مشخص کنید و از مزایای چک کردن نوع (type checking) بهره‌مند شوید.

مثال با const:
#include <iostream>

const int X_0 = 76;

int main() {
    std::cout << "Value of X_0 is: " << X_0 << std::endl;
    return 0;
}


استفاده از const همچنین به شما اجازه می‌دهد تا از قابلیت‌های C++ مانند namespaces و scope استفاده کنید.

کتابخانه windows.h در C++ یک کتابخانه هدر است که شامل توابع و تعاریف مربوط به برنامه‌نویسی در سیستم‌عامل ویندوز می‌باشد. این کتابخانه به برنامه‌نویسان اجازه می‌دهد تا به ویژگی‌ها و APIهای ویندوز دسترسی پیدا کنند، از جمله مدیریت پنجره‌ها، مدیریت رویدادها، کار با فایل‌ها، و بسیاری دیگر از قابلیت‌های سیستم‌عامل.

▎کاربردهای رایج windows.h:

1. مدیریت پنجره‌ها: می‌توانید پنجره‌های گرافیکی بسازید و کنترل کنید. این شامل ایجاد، نمایش، پنهان کردن و مدیریت رویدادهای پنجره‌ها (مثل کلیک ماوس و فشار دادن کلید) است.

2. دستورات گرافیکی: با استفاده از توابع گرافیکی ویندوز می‌توانید اشکال، متن و تصاویر را روی پنجره‌ها رسم کنید.

3. مدیریت فرآیندها و نخ‌ها: می‌توانید فرآیندها (processes) و نخ‌ها (threads) را ایجاد، مدیریت و هماهنگ کنید.

4. دسترسی به سیستم فایل: این کتابخانه به شما امکان می‌دهد تا با فایل‌ها و دایرکتوری‌ها کار کنید، مانند خواندن و نوشتن فایل‌ها یا تغییر ویژگی‌های آن‌ها.

5. مدیریت خطا: توابعی برای مدیریت خطاها و دریافت اطلاعات بیشتر در مورد خطاهای سیستم‌عامل فراهم می‌کند.

6. دستورات شبکه: می‌توانید به توابعی برای کار با شبکه و ارتباطات شبکه‌ای دسترسی پیدا کنید.

▎مثال ساده:

در زیر یک مثال ساده از استفاده از windows.h برای ایجاد یک پنجره خالی آورده شده است:

#include <windows.h>

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    switch (uMsg) {
        case WM_DESTROY:
            PostQuitMessage(0);
            return 0;
        case WM_PAINT:
            {
                PAINTSTRUCT ps;
                HDC hdc = BeginPaint(hwnd, &ps);
                FillRect(hdc, &ps.rcPaint, (HBRUSH)(COLOR_WINDOW + 1));
                EndPaint(hwnd, &ps);
            }
            return 0;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int nShowCmd) {
    const char CLASS_NAME[] = "Sample Window Class";

    WNDCLASS wc = {};
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = CLASS_NAME;

    RegisterClass(&wc);

    HWND hwnd = CreateWindowEx(
        0,
        CLASS_NAME,
        "Sample Window",
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
        NULL,
        NULL,
        hInstance,
        NULL
    );

    ShowWindow(hwnd, nShowCmd);

    MSG msg = {};
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return 0;
}


▎توضیحات کد:

• WindowProc: تابعی است که رویدادهای پنجره را مدیریت می‌کند.

• WinMain: نقطه ورود برنامه در ویندوز است.

• CreateWindowEx: یک پنجره جدید ایجاد می‌کند.

• GetMessage, TranslateMessage, DispatchMessage: این توابع برای دریافت و پردازش پیام‌ها (رویدادها) استفاده می‌شوند.

این کد یک پنجره خالی ایجاد می‌کند که می‌تواند بسته شود. این فقط یک شروع است و می‌توان با افزودن قابلیت‌های بیشتر، یک برنامه کامل‌تر ساخت.

درسنامه شماره (۳)

کدی که ارائه داده‌اید، یک تابع به نام Draw را تعریف می‌کند که یک مستطیل را روی یک دستگاه نمایش (HDC) رسم می‌کند. در اینجا جزئیات بیشتری درباره کاربرد این کد و اجزای آن آورده شده است:

▎توضیحات کد:

void Draw(HDC hdc){
    Rectangle(hdc, pos_O_x , pos_O_y , pos_O_x + 10 , pos_O_y + 10);
}


▎اجزای کد:

1. HDC hdc: 

   • HDC مخفف "Handle to Device Context" است و به یک ساختار داده‌ای اشاره دارد که اطلاعات مربوط به دستگاه گرافیکی را نگه‌داری می‌کند. این شامل اطلاعاتی درباره رنگ‌ها، قلم‌ها و دیگر ویژگی‌های گرافیکی است.

   • تابع Draw نیاز دارد که یک HDC به عنوان ورودی دریافت کند تا بتواند بر روی آن رسم کند.

2. Rectangle:

   • تابع Rectangle از کتابخانه windows.h استفاده می‌شود تا یک مستطیل را بر روی دستگاه نمایش رسم کند.

   • پارامترهای این تابع شامل hdc (دستگاه نمایش)، مختصات گوشه بالای سمت چپ مستطیل (pos_O_x, pos_O_y) و مختصات گوشه پایین سمت راست مستطیل (pos_O_x + 10, pos_O_y + 10) است.

   • در اینجا، مستطیلی با ابعاد 10x10 پیکسل رسم می‌شود.

3. posOx و posOy:

   • این دو متغیر (که در کد شما تعریف نشده‌اند) نشان‌دهنده مختصات x و y برای موقعیت گوشه بالای سمت چپ مستطیل هستند.

   • شما باید این متغیرها را در کد خود تعریف کنید و مقداردهی کنید تا موقعیت مستطیل مشخص شود.

▎کاربردهای این کد:

1. رسم اشکال گرافیکی: این تابع می‌تواند به عنوان بخشی از یک برنامه گرافیکی باشد که نیاز به رسم اشکال (مستطیل، دایره، خط و غیره) دارد. به عنوان مثال، می‌توانید از آن برای نمایش اشیاء در یک بازی یا برنامه گرافیکی استفاده کنید.

2. بخش‌های رابط کاربری: می‌توانید از این تابع برای رسم اجزای مختلف رابط کاربری (UI) مانند دکمه‌ها، نوارها و دیگر عناصر گرافیکی استفاده کنید.

3. تحلیل داده‌ها: اگر بخواهید داده‌ها را به صورت بصری نمایش دهید، می‌توانید از این تابع برای رسم نمودارها یا اشکال دیگر استفاده کنید.

4. انیمیشن: با تغییر مداوم مقادیر pos_O_x و pos_O_y و فراخوانی مجدد تابع Draw، می‌توانید انیمیشن‌های ساده‌ای ایجاد کنید.

▎نتیجه‌گیری:

به طور کلی، این کد یک بخش ساده اما مهم از یک برنامه گرافیکی است که می‌تواند در موقعیت‌های مختلف مورد استفاده قرار گیرد. برای اینکه این تابع به درستی کار کند، باید در یک محیط مناسب (مانند رویداد WM_PAINT) فراخوانی شود و HDC صحیحی به آن پاس داده شود.

درسنامه شماره (۴)

البته! در اینجا به توضیح کلمه به کلمه دستور LRESULT CALLBACK Window_and_Print_Board(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) که یک تابع در C++ است، می‌پردازیم:

▎توضیحات کلمه به کلمه:

1. LRESULT:

   • این نوع داده‌ای است که معمولاً برای بازگرداندن نتیجه‌ای از یک تابع در Windows API استفاده می‌شود. 

   • به طور خاص، LRESULT نوعی عدد صحیح است که می‌تواند برای نشان دادن وضعیت یا نتیجه یک رویداد (event) یا پیام (message) استفاده شود.

2. CALLBACK:

   • این یک ماکرو است که به تابع اعلام می‌کند که یک تابع callback است. 

   • تابع callback به توابعی اطلاق می‌شود که به عنوان پارامتر به دیگر توابع ارسال می‌شوند و معمولاً برای پردازش رویدادها (event handling) استفاده می‌شوند.

3. WindowandPrint_Board:

   • این نام تابع است. نام‌گذاری توابع باید معنادار باشد و در اینجا نشان‌دهنده این است که تابع مربوط به پنجره (Window) و چاپ (Print) است.

   • نام تابع باید با قواعد نام‌گذاری زبان C++ سازگار باشد.

4. (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam):

   • این بخش لیست پارامترهای تابع را مشخص می‌کند. هر پارامتر یک نوع داده و یک نام دارد:

   
   • HWND hwnd:

     • HWND نوعی داده است که نمایانگر یک "هندل" (handle) به یک پنجره در Windows API است. 

     • hwnd نام پارامتری است که اشاره‌گر به پنجره‌ای را که پیام به آن ارسال شده، نگه می‌دارد.

   • UINT uMsg:

     • UINT نوعی داده صحیح بدون علامت است که معمولاً برای شناسایی نوع پیام (message) ارسال شده به پنجره استفاده می‌شود. 

     • uMsg نام پارامتری است که نوع پیام را مشخص می‌کند.

   • WPARAM wParam:

     • WPARAM نوعی داده است که معمولاً برای نگهداری اطلاعات اضافی در مورد پیام استفاده می‌شود. 

     • wParam نام پارامتری است که اطلاعات اضافی مربوط به پیام را نگه می‌دارد.

   • LPARAM lParam:

     • LPARAM نیز نوعی داده است که به طور معمول برای نگهداری اطلاعات بیشتر یا مقادیر بزرگ‌تر از WPARAM استفاده می‌شود.

     • lParam نام پارامتری است که اطلاعات اضافی یا مقادیر مربوط به پیام را نگه می‌دارد.

▎نتیجه‌گیری:

تابع LRESULT CALLBACK Window_and_Print_Board(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) یک تابع callback است که برای پردازش پیام‌های دریافتی از سیستم عامل Windows طراحی شده است. این تابع به طور معمول در برنامه‌های کاربردی گرافیکی برای مدیریت رویدادها و تعامل با کاربر استفاده می‌شود. پارامترهای آن شامل اطلاعات مربوط به پنجره، نوع پیام و اطلاعات اضافی هستند که به برنامه‌نویس اجازه می‌دهند تا رفتار پنجره را بر اساس پیام‌های دریافتی کنترل کند.

درسنامه شماره (۵)

در زبان برنامه‌نویسی C و C++، ماکروها بخشی از پیش‌پردازنده (preprocessor) هستند که به شما اجازه می‌دهند تا کد را به صورت متنی دستکاری کنید قبل از اینکه کامپایلر آن را به کد ماشین تبدیل کند. ماکروها معمولاً برای تعریف ثابت‌ها، تابع‌های کوتاه، یا تغییرات در کد استفاده می‌شوند.

### CALLBACK به عنوان یک ماکرو

CALLBACK یک ماکرو است که در Windows API تعریف شده و به تابع‌ها اعلام می‌کند که آن‌ها تابع‌های callback هستند. این ماکرو معمولاً به صورت زیر تعریف می‌شود:

#define CALLBACK __stdcall
### توضیح اجزای CALLBACK:

1. __stdcall:
   - این یک نوع فراخوانی (calling convention) است که مشخص می‌کند چگونه پارامترها به تابع منتقل می‌شوند و چگونه کنترل به تابع بازمی‌گردد.
   - در __stdcall، پارامترها از راست به چپ منتقل می‌شوند و مسئولیت پاک‌سازی پشته (stack cleanup) بر عهده تابعی است که فراخوانی شده است.
   - این نوع فراخوانی در Windows API رایج است و به طور خاص برای توابع callback استفاده می‌شود.

### چرا از ماکروها استفاده می‌شود؟

- قابل حملی: با استفاده از ماکروها، می‌توانید کد خود را برای پلتفرم‌های مختلف سازگار کنید. به عنوان مثال، اگر در یک سیستم‌عامل دیگر نیاز به تغییر نوع فراخوانی داشتید، فقط کافی است ماکرو را تغییر دهید.
  
- ساده‌سازی کد: ماکروها می‌توانند کد شما را خواناتر کنند و از تکرار جلوگیری کنند. به جای نوشتن نوع فراخوانی هر بار، فقط کافی است از ماکرو CALLBACK استفاده کنید.

### نتیجه‌گیری

در نهایت، وقتی شما CALLBACK را در تعریف تابع خود استفاده می‌کنید، به کامپایلر می‌گویید که این تابع یک تابع callback است و باید با استفاده از نوع فراخوانی مشخص شده (مانند __stdcall) کامپایل شود. این کار باعث می‌شود که مدیریت پیام‌ها و رویدادها در برنامه‌های Windows ساده‌تر و منظم‌تر شود.

درسنامه شماره (۶)

کدی که ارائه داده‌اید، تابعی به نام Window_and_Print_Board است که به عنوان یک تابع callback برای مدیریت پیام‌های مربوط به یک پنجره در برنامه‌های ویندوز نوشته شده است. این تابع از کتابخانه windows.h استفاده می‌کند و شامل چندین بخش مختلف است که هر یک وظیفه خاصی را انجام می‌دهند. بیایید کد را خط به خط بررسی کنیم:

▎تعریف تابع

LRESULT CALLBACK Window_and_Print_Board(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {


• LRESULT: نوع داده‌ای که نتیجه‌ای را که تابع برمی‌گرداند مشخص می‌کند.

• CALLBACK: ماکرو برای مشخص کردن نوع فراخوانی تابع (در اینجا __stdcall).

• HWND hwnd: شناسه پنجره‌ای که پیام به آن ارسال شده است.

• UINT uMsg: نوع پیام (مثل WMCREATE، WMPAINT و غیره).

• WPARAM wParam: اطلاعات اضافی درباره پیام (مثل کلید فشرده شده).

• LPARAM lParam: اطلاعات اضافی دیگر.

▎مدیریت پیام‌ها با switch

switch (uMsg) {

این بخش برای پردازش پیام‌های مختلف استفاده می‌شود. هر پیام به یک بخش خاص از کد منتهی می‌شود.

▎پردازش پیام WM_CREATE

case WM_CREATE: {
    HRGN hRgn = CreateRoundRectRgn(20, 20, 400, 50, 50, 50);
    HWND Label = CreateWindow("STATIC", " Maze_Project_for_BP_Class | Teacher : Taybeh Rafiei | 1403_1404 ",
        WS_VISIBLE | WS_CHILD, 15, 5, 1040, 20,
        hwnd, nullptr, nullptr, nullptr);
    SetWindowRgn(Label, hRgn, TRUE);
    break;
}


• WM_CREATE: پیام ایجاد پنجره است.

• CreateRoundRectRgn: یک ناحیه با گوشه‌های گرد ایجاد می‌کند.

• CreateWindow: یک کنترل (در اینجا یک برچسب) ایجاد می‌کند.

• SetWindowRgn: ناحیه ایجاد شده را به کنترل اختصاص می‌دهد.

▎پردازش پیام WM_DESTROY

case WM_DESTROY:
    PostQuitMessage(0);
    return 0;


• WM_DESTROY: پیام تخریب پنجره است.

• PostQuitMessage(0): به سیستم عامل اعلام می‌کند که برنامه باید خاتمه یابد.

▎پردازش پیام WM_SIZE

case WM_SIZE:
    SetWindowPos(hwnd, NULL, 0, 0, 1080, 720, SWP_NOZORDER);
    return 0;


• WM_SIZE: زمانی که اندازه پنجره تغییر می‌کند، این پیام ارسال می‌شود.

• SetWindowPos: اندازه پنجره را به 1080x720 پیکسل تنظیم می‌کند.

▎پردازش پیام WM_PAINT

case WM_PAINT: {
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint(hwnd, &ps);
    
    HPEN hPenRed = CreatePen(PS_SOLID, 5, RGB(255, 0, 0));
    SelectObject(hdc, hPenRed);
    MoveToEx(hdc, 17, 25, NULL);
    LineTo(hdc, 1052, 25);
   
    Draw(hdc);
  
    HPEN Maze_Board_G = CreatePen(PS_SOLID, 13, RGB(40, 152, 7));
    for (int i = 1 ; i < 1162 ; i++){
        SelectObject(hdc, Maze_Board_G);
        MoveToEx(hdc, XY[i][0] ,XY[i][1] , NULL);
        LineTo(hdc, XY[i][2] ,XY[i][3]);
    }
    
    EndPaint(hwnd, &ps);
    Sleep(500);
    break;
}


• WM_PAINT: پیام مربوط به رسم محتویات پنجره است.

• BeginPaint: شروع فرآیند رسم را نشان می‌دهد و یک HDC (دستگاه زمینه) دریافت می‌کند.

• CreatePen: یک قلم با رنگ و ضخامت مشخص ایجاد می‌کند.

• SelectObject: قلم ایجاد شده را به HDC اختصاص می‌دهد.

• MoveToEx و LineTo: خطوطی را بر روی HDC رسم می‌کنند.

• Draw(hdc): تابعی که احتمالا برای رسم سایر اشکال یا محتویات استفاده می‌شود.

• حلقه برای رسم خطوط در مختصات مشخص شده از آرایه XY.

• EndPaint: پایان فرآیند رسم را نشان می‌دهد و منابع را آزاد می‌کند.

• Sleep(500): برنامه را برای نیم ثانیه متوقف می‌کند.

▎پردازش پیام WM_KEYDOWN

case WM_KEYDOWN:
    if (((pos_O_x > 496) and (pos_O_x < 516)) and (pos_O_y == 75)){
        MessageBox(hwnd, "", "ajab", MB_OK);
        Sleep(1500);
        ExitProcess(0);
    } 
    if (wParam == VK_RIGHT){
        // حرکت به راست
    } else if (wParam == VK_LEFT){
        // حرکت به چپ
    } else if (wParam == VK_UP){
        // حرکت به بالا
    } else if (wParam == VK_DOWN){
        // حرکت به پایین
    }
    InvalidateRect(hwnd, NULL, TRUE);
    break;


• WM_KEYDOWN: زمانی که یک کلید بر روی صفحه کلید فشرده می‌شود، این پیام ارسال می‌شود.

• بررسی موقعیت فعلی (pos_O_x و pos_O_y) و نمایش یک پیام با استفاده از MessageBox در صورت برآورده شدن شرط خاص.

• هر بخش از کد برای کلیدهای جهت‌دار (VK_RIGHT, VK_LEFT, VK_UP, VK_DOWN) شامل منطق حرکت شیء (pos_O_x, pos_O_y) در صفحه است.

• InvalidateRect: ناحیه‌ای از پنجره را برای رسم مجدد نامعتبر می‌کند.

▎پردازش پیام WM_ERASEBKGND

case WM_ERASEBKGND: {
    HDC hdc = (HDC)wParam;
    RECT rect;
    GetClientRect(hwnd, &rect);
    HBRUSH brush = CreateSolidBrush(RGB(180, 170, 120));
    FillRect(hdc, &rect, brush);
    DeleteObject(brush);
    return 1;
}


• WM_ERASEBKGND: زمانی که پس‌زمینه پنجره باید پاک شود، این پیام ارسال می‌شود.

• گرفتن HDC از پارامتر ورودی.

• گرفتن ابعاد پنجره با استفاده از GetClientRect.

• ایجاد یک برس با رنگ مشخص و پر کردن ناحیه پنجره با آن.

• آزاد کردن منابع با استفاده از DeleteObject.

▎پایان تابع

return DefWindowProc(hwnd, uMsg, wParam, lParam);

اگر هیچ‌یک از موارد بالا پاسخگو نبود، تابع اصلی ویندوز برای پردازش پیام‌ها صدا زده می‌شود.

▎نتیجه‌گیری

این کد یک پنجره گرافیکی ساده ایجاد می‌کند که قادر به مدیریت رویدادها و تعامل با کاربر است. این برنامه همچنین شامل منطق حرکت اشیاء در صفحه و رسم خطوط و اشکال مختلف بر روی پنجره است.

درسنامه شماره (۷)

البته! بیایید بخش WinMain را خط به خط بررسی کنیم. این تابع نقطه ورود اصلی برای برنامه‌های ویندوزی است و به طور خاص برای برنامه‌های گرافیکی نوشته شده با استفاده از کتابخانه windows.h در زبان C++ استفاده می‌شود.

▎توضیح کد WinMain

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int nShowCmd) {


1. int WINAPI WinMain(...): 

   • WinMain تابع اصلی برنامه‌های ویندوزی است که به جای main استفاده می‌شود. 

   • نوع بازگشتی این تابع int است، که معمولاً برای نشان دادن وضعیت خاتمه برنامه استفاده می‌شود.

   • WINAPI یک نوع فراخوانی (calling convention) است که مشخص می‌کند چگونه پارامترها به تابع منتقل می‌شوند و چگونه کنترل به تابع بازگردانده می‌شود. این نوع فراخوانی برای توابع API ویندوز استفاده می‌شود.

2. پارامترها:

   • HINSTANCE hInstance: این پارامتر یک شناسه برای نمونه (instance) فعلی برنامه است. این شناسه به شما اجازه می‌دهد تا به منابع (مانند فایل‌های .rc یا دکمه‌ها) دسترسی پیدا کنید.

   • HINSTANCE: پارامتر دوم که معمولاً نادیده گرفته می‌شود، نمایانگر نمونه والد (parent instance) است. در اکثر برنامه‌ها نیازی به استفاده از آن نیست.

   • LPSTR: پارامتر سوم یک رشته (string) است که معمولاً برای آرگومان‌های خط فرمان استفاده می‌شود. در بسیاری از برنامه‌ها نیز نادیده گرفته می‌شود.

   • int nShowCmd: این پارامتر مشخص می‌کند که پنجره چگونه باید نمایش داده شود. مقادیر مختلفی دارد، مانند SW_SHOW, SW_HIDE, و غیره.

▎ادامه‌ی تابع

پس از تعریف تابع، معمولاً کدهای زیر درون آن قرار می‌گیرند:

    // کدهای مربوط به ثبت کلاس پنجره و ایجاد پنجره
    // و همچنین حلقه پیام (message loop) در اینجا قرار می‌گیرد
}


▎مثال ساده از محتوای تابع

در ادامه، یک مثال ساده از محتوای تابع WinMain را ارائه می‌دهم:

    // ثبت کلاس پنجره
    WNDCLASS wc = {};
    wc.lpfnWndProc = WindowProc;  // تابع پردازش پیام
    wc.hInstance = hInstance;
    wc.lpszClassName = "SampleWindowClass";

    RegisterClass(&wc);

    // ایجاد پنجره
    HWND hwnd = CreateWindowEx(
        0,
        wc.lpszClassName,
        "Sample Window",
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
        NULL,
        NULL,
        hInstance,
        NULL
    );

    if (hwnd == NULL) {
        return 0; // اگر پنجره ایجاد نشد، خروج
    }

    ShowWindow(hwnd, nShowCmd); // نمایش پنجره
    UpdateWindow(hwnd);          // به‌روزرسانی پنجره

    // حلقه پیام
    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return 0; // پایان برنامه


▎توضیح محتوای تابع

1. ثبت کلاس پنجره:

   • WNDCLASS wc = {};: یک ساختار WNDCLASS ایجاد می‌کند و آن را با صفر مقداردهی اولیه می‌کند.

   • wc.lpfnWndProc = WindowProc;: مشخص می‌کند که کدام تابع پیام‌ها را پردازش خواهد کرد.

   • RegisterClass(&wc);: کلاس پنجره را ثبت می‌کند.

2. ایجاد پنجره:

   • CreateWindowEx(...): پنجره‌ای جدید ایجاد می‌کند و اطلاعات مربوط به آن را از جمله عنوان، نوع و اندازه آن مشخص می‌کند.

3. نمایش پنجره:

   • ShowWindow(hwnd, nShowCmd);: پنجره را بر اساس پارامتر nShowCmd نمایش می‌دهد.

   • UpdateWindow(hwnd);: پنجره را به‌روزرسانی می‌کند تا محتوای آن رسم شود.

4. حلقه پیام:

   • while (GetMessage(&msg, NULL, 0, 0)) {...}: یک حلقه بی‌نهایت برای دریافت پیام‌ها از سیستم عامل و پردازش آن‌ها.

   • TranslateMessage(&msg);: پیام‌های کلیدی را ترجمه می‌کند.

   • DispatchMessage(&msg);: پیام‌ها را به تابع پردازش پیام ارسال می‌کند.

5. پایان برنامه:

   • return 0;: نشان‌دهنده پایان موفقیت‌آمیز برنامه است.

این توضیحات به شما کمک می‌کند تا مفهوم و ساختار تابع WinMain را بهتر درک کنید. اگر سوالات بیشتری دارید یا به توضیحات بیشتری نیاز دارید، لطفاً بفرمایید!

درسنامه شماره (۸)

البته! بیایید این قسمت از کد را به تفصیل بررسی کنیم:

▎1. تعریف نام کلاس پنجره

const char CLASS_NAME[] = "Sample Window Class";


• const char CLASS_NAME[]: این خط یک آرایه از نوع char (رشته) تعریف می‌کند که نام کلاس پنجره را نگه می‌دارد. 

• "Sample Window Class": این رشته به عنوان نام کلاس پنجره استفاده خواهد شد. نام کلاس باید منحصر به فرد باشد و معمولاً برای شناسایی نوع پنجره‌ای که می‌خواهیم ایجاد کنیم، استفاده می‌شود.

▎2. تعریف و مقداردهی ساختار WNDCLASS

WNDCLASS wc = {};


• WNDCLASS wc: این خط یک متغیر از نوع WNDCLASS تعریف می‌کند. WNDCLASS یک ساختار است که اطلاعات لازم برای ایجاد یک کلاس پنجره را نگه می‌دارد.

• = {}: این دستور باعث می‌شود که تمام اعضای ساختار wc به طور پیش‌فرض مقداردهی شوند (به صفر). این کار اطمینان می‌دهد که هیچ مقداری در این ساختار باقی نمانده است و فقط اعضای مورد نیاز بعداً مقداردهی می‌شوند.

▎3. تنظیم ویژگی‌های کلاس پنجره

wc.lpfnWndProc = Window_and_Print_Board;


• wc.lpfnWndProc: این عضو از ساختار WNDCLASS اشاره‌گری به تابعی است که وظیفه پردازش پیام‌های پنجره را بر عهده دارد. 

• Window_and_Print_Board: این نام تابعی است که پیام‌ها را پردازش می‌کند. وقتی که رویدادهایی مانند کلیک موس یا بسته شدن پنجره رخ می‌دهد، این تابع فراخوانی می‌شود تا به آن‌ها پاسخ دهد.

wc.hInstance = hInstance;


• wc.hInstance: این عضو شناسه نمونه برنامه (HINSTANCE) را نگه می‌دارد. این شناسه به سیستم عامل کمک می‌کند تا بفهمد کدام نمونه از برنامه در حال اجرا است.

• hInstance: معمولاً این متغیر در تابع WinMain به عنوان آرگومان ورودی دریافت می‌شود و به عنوان شناسه نمونه برنامه استفاده می‌شود.

wc.lpszClassName = CLASS_NAME;


• wc.lpszClassName: این عضو نام کلاسی را که در ابتدا تعریف کردیم (یعنی CLASS_NAME) نگه می‌دارد. این نام برای شناسایی کلاس پنجره در زمان ثبت آن استفاده می‌شود.

▎4. ثبت کلاس پنجره

RegisterClass(&wc);


• RegisterClass(&wc): این تابع کلاس پنجره‌ای را که در ساختار wc تعریف شده است، ثبت می‌کند. 

• با ثبت کلاس، سیستم عامل ویندوز می‌تواند از آن برای ایجاد پنجره‌های جدید استفاده کند. اگر ثبت کلاس موفقیت‌آمیز باشد، سیستم عامل اطلاعات مربوط به این کلاس را ذخیره می‌کند و در هنگام ایجاد پنجره‌ها از آن استفاده می‌کند.

▎نتیجه‌گیری

این بخش از کد مسئول تعریف و ثبت یک کلاس پنجره در ویندوز است. با استفاده از این کلاس، شما قادر خواهید بود پنجره‌هایی با ویژگی‌ها و رفتارهای خاص خود ایجاد کنید. اگر سوالات بیشتری دارید یا نیاز به توضیحات بیشتری در مورد هر قسمت دارید، خوشحال می‌شوم کمک کنم!

درسنامه شماره (۹)

بله، بیایید این قطعه کد را به تفصیل بررسی کنیم. این کد برای ایجاد یک پنجره در ویندوز با استفاده از کتابخانه windows.h نوشته شده است.

▎1. ایجاد پنجره

HWND hwnd = CreateWindowEx(
    0,
    CLASS_NAME,
    "Maze Project",
    WS_OVERLAPPEDWINDOW & ~WS_MAXIMIZEBOX,
    CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
    NULL,
    NULL,
    hInstance,
    NULL
);


• HWND hwnd: این خط یک متغیر از نوع HWND تعریف می‌کند که نمایانگر دستگیره (handle) پنجره‌ای است که قرار است ایجاد شود. 

• CreateWindowEx: این تابع برای ایجاد یک پنجره جدید استفاده می‌شود. آرگومان‌های این تابع به شرح زیر است:

  • 0: این آرگومان نشان‌دهنده ویژگی‌های اضافی پنجره است. در اینجا هیچ ویژگی اضافی مشخص نشده است.

  
  • CLASS_NAME: نام کلاسی که قبلاً ثبت شده است و این پنجره بر اساس آن ایجاد می‌شود.

  
  • "Maze Project": عنوان پنجره که در نوار عنوان نمایش داده می‌شود.

  
  • WS_OVERLAPPEDWINDOW & ~WS_MAXIMIZEBOX: این آرگومان شامل سبک‌های پنجره است. در اینجا، پنجره به صورت یک پنجره معمولی با قابلیت کاهش و بستن نمایش داده می‌شود، اما دکمه حداکثر کردن (Maximize) غیرفعال شده است.

  
  • CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT: این چهار آرگومان مشخص‌کننده موقعیت و اندازه پنجره هستند. CW_USEDEFAULT به سیستم می‌گوید که از مقادیر پیش‌فرض استفاده کند.

  
  • NULL: این آرگومان نشان‌دهنده دستگیره والد (parent) پنجره است. در اینجا، پنجره والد وجود ندارد.

  
  • NULL: این آرگومان نشان‌دهنده منوی پنجره است. در اینجا، منویی برای پنجره وجود ندارد.

  
  • hInstance: شناسه نمونه برنامه که قبلاً تعریف شده است و به سیستم کمک می‌کند تا بداند کدام نمونه از برنامه در حال اجرا است.

  
  • NULL: این آرگومان به عنوان داده اضافی به تابع ارسال می‌شود، که در اینجا خالی است.

▎2. نمایش پنجره

ShowWindow(hwnd, nShowCmd);


• ShowWindow(hwnd, nShowCmd): این تابع برای نمایش پنجره‌ای که با CreateWindowEx ایجاد شده، استفاده می‌شود.

• hwnd: دستگیره پنجره‌ای که باید نمایش داده شود.

• nShowCmd: مشخص می‌کند که پنجره چگونه باید نمایش داده شود (به عنوان مثال، به صورت عادی، مخفی، بزرگ‌شده و غیره).

▎3. پردازش پیام‌ها

MSG msg;
while (GetMessage(&msg, NULL, 0, 0)) {
    TranslateMessage(&msg);
    DispatchMessage(&msg);
}


• MSG msg;: یک متغیر از نوع MSG تعریف می‌کند که برای نگهداری پیام‌های دریافتی از سیستم عامل استفاده می‌شود.

  
• GetMessage(&msg, NULL, 0, 0): این تابع پیام‌ها را از صف پیام‌ها دریافت می‌کند. اگر پیام جدیدی وجود داشته باشد، آن را در متغیر msg قرار می‌دهد و تابع مقدار غیر صفر برمی‌گرداند. اگر هیچ پیام جدیدی وجود نداشته باشد، تابع صفر برمی‌گرداند و حلقه خاتمه پیدا می‌کند.

  
• TranslateMessage(&msg): این تابع پیام‌های ورودی (مثل کلیدهای فشرده شده) را ترجمه می‌کند و پیام‌های اضافی را به صف پیام‌ها اضافه می‌کند.

  
• DispatchMessage(&msg): این تابع پیام را به تابع پردازش پیام مربوط به پنجره ارسال می‌کند تا پردازش شود.

▎4. پایان برنامه

return 0;


• این خط نشان‌دهنده پایان تابع main یا WinMain است و به سیستم عامل بازگشت مقدار صفر (موفقیت) را اعلام می‌کند.

▎نتیجه‌گیری

این قطعه کد مسئول ایجاد و نمایش یک پنجره در ویندوز و پردازش پیام‌های آن است. با استفاده از توابع موجود در کتابخانه windows.h, شما قادر خواهید بود یک برنامه گرافیکی ساده بسازید که با کاربر تعامل داشته باشد. اگر سوالات بیشتری دارید یا نیاز به توضیحات بیشتری دارید، خوشحال می‌شوم کمک کنم!

درسنامه شماره (۱۰)
مرور کلی بر روی کد اصلی

کدی که ارائه داده‌اید، یک برنامه ساده ویندوزی است که به نظر می‌رسد یک بازی یا شبیه‌سازی از یک ماز (Maze) را پیاده‌سازی می‌کند. این برنامه از توابع و ساختارهای پایه‌ای ویندوز استفاده می‌کند. در ادامه، توضیح مختصری از بخش‌های مختلف این کد ارائه می‌شود:

▎1. شامل کردن کتابخانه‌ها و تعریف متغیرها

#include <windows.h>
#include <stdio.h>
#define X_0 76
#define X_1 996
#define Y_0 75
#define Y_1 625

int n = 0;
int pos_O_x = 76;
int pos_O_y = 625;


• #include <windows.h>: کتابخانه‌ای که شامل توابع و ساختارهای ویندوز است.

• #define: مقادیر ثابت برای مرزهای ماز تعریف شده‌اند.

• int n و pos_O_x, pos_O_y: متغیرهایی برای نگهداری وضعیت و موقعیت اشیاء در پنجره.

▎2. تابع Draw

void Draw(HDC hdc){
    Rectangle(hdc, pos_O_x , pos_O_y , pos_O_x + 10 , pos_O_y + 10);
}


• این تابع یک مستطیل کوچک در موقعیت (pos_O_x, pos_O_y) رسم می‌کند که نشان‌دهنده موقعیت فعلی یک شیء (احتمالاً کاربر یا یک شیء در ماز) است.

▎3. تابع WindowandPrint_Board

LRESULT CALLBACK Window_and_Print_Board(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    HDC hdc;
    switch (uMsg) {
        // ...
    }
}


• این تابع به عنوان تابع پردازش پیام برای پنجره تعریف شده است. بسته به نوع پیام دریافتی (uMsg)، اقدامات مختلفی انجام می‌دهد.

▎- WM_CREATE

case WM_CREATE: {
    HRGN hRgn = CreateRoundRectRgn(20, 20, 400, 50, 50, 50);
    HWND Label = CreateWindow("STATIC", " Maze_Project_for_BP_Class ...", WS_VISIBLE | WS_CHILD, 15, 5, 1040, 20,
        hwnd, nullptr, nullptr, nullptr);
    SetWindowRgn(Label, hRgn, TRUE);
    break;
}


• هنگام ایجاد پنجره، یک ناحیه گرد ایجاد می‌کند و یک برچسب (Label) با عنوان مشخصی در بالای پنجره قرار می‌دهد.

▎- WM_DESTROY

case WM_DESTROY:
    PostQuitMessage(0);
    return 0;


• زمانی که پنجره بسته می‌شود، پیام خروج ارسال می‌کند.

▎- WM_SIZE

case WM_SIZE:
    SetWindowPos(hwnd, NULL, 0, 0, 1080, 720, SWP_NOZORDER);
    return 0;


• اندازه پنجره را به (1080, 720) تنظیم می‌کند.

▎- WM_PAINT

case WM_PAINT: {
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint(hwnd, &ps);
    
    HPEN hPenRed = CreatePen(PS_SOLID, 5, RGB(255, 0, 0));
    SelectObject(hdc, hPenRed);
    MoveToEx(hdc, 17, 25, NULL);
    LineTo(hdc, 1052, 25);
    
    Draw(hdc);
    
    HPEN Maze_Board_G = CreatePen(PS_SOLID, 13, RGB(40, 152, 7));
    for (int i = 1 ; i < 1162 ; i++){
        SelectObject(hdc, Maze_Board_G);
        MoveToEx(hdc, XY[i][0] ,XY[i][1] , NULL);
        LineTo(hdc, XY[i][2] ,XY[i][3]);
    }
    
    EndPaint(hwnd, &ps);
    Sleep(500);
    break;
}


• هنگام نیاز به نقاشی مجدد پنجره، خطوط و مستطیل‌ها را با استفاده از Draw رسم می‌کند.

• همچنین، خطوط ماز را بر اساس آرایه‌ای به نام XY رسم می‌کند.

▎- WM_KEYDOWN

case WM_KEYDOWN:
    if (((pos_O_x > 496) and (pos_O_x < 516)) and (pos_O_y == 75)){
        MessageBox(hwnd, "", "ajab", MB_OK);
        Sleep(1500);
        ExitProcess(0);
    } 
    if (wParam == VK_RIGHT) {
        // حرکت به راست
    }
    else if (wParam == VK_LEFT) {
        // حرکت به چپ
    }
    else if (wParam == VK_UP) {
        // حرکت به بالا
    }
    else if (wParam == VK_DOWN) {
        // حرکت به پایین
    }
    InvalidateRect(hwnd, NULL, TRUE);
    break;


• این بخش برای مدیریت ورودی‌های کلیدهای جهت‌دار (چپ، راست، بالا، پایین) استفاده می‌شود و موقعیت شیء را بر اساس آن تغییر می‌دهد.

• همچنین اگر شیء در موقعیت خاصی باشد، یک پیام باکس نمایش می‌دهد و برنامه را خاتمه می‌دهد.

▎- WM_ERASEBKGND

case WM_ERASEBKGND: {
    HDC hdc = (HDC)wParam;
    RECT rect;
    GetClientRect(hwnd, &rect);
    HBRUSH brush = CreateSolidBrush(RGB(180, 170, 120));
    FillRect(hdc, &rect, brush);
    DeleteObject(brush);
    return 1;
}


• این بخش برای پاک کردن پس‌زمینه پنجره استفاده می‌شود و رنگ پس‌زمینه را تنظیم می‌کند.

▎4. تابع WinMain

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int nShowCmd) {
    const char CLASS_NAME[] = "Sample Window Class";

    WNDCLASS wc = {};
    wc.lpfnWndProc = Window_and_Print_Board;

    wc.hInstance = hInstance;
    wc.lpszClassName = CLASS_NAME;

    RegisterClass(&wc);
}


• این تابع نقطه ورود برنامه است. در اینجا کلاس پنجره ثبت شده و آماده ایجاد پنجره می‌شود.

▎نتیجه‌گیری

این کد یک برنامه ویندوزی ساده است که شامل ایجاد یک پنجره، مدیریت ورودی‌های کلید، رسم اشیاء و خطوط در پنجره است. این برنامه به نظر می‌رسد که بخشی از یک بازی یا شبیه‌سازی از یک ماز باشد. اگر سوال خاصی دارید یا نیاز به توضیحات بیشتری دارید، لطفاً بفرمایید!

البته! بیایید به بخش کدی که ارائه داده‌اید نگاهی بیندازیم و هر قسمت را به طور مختصر توضیح دهیم.

▎1. ایجاد پنجره

HWND hwnd = CreateWindowEx(
    0,
    CLASS_NAME,
    "Maze Project",
    WS_OVERLAPPEDWINDOW & ~WS_MAXIMIZEBOX,
    CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
    NULL,
    NULL,
    hInstance,
    NULL
);


• CreateWindowEx: این تابع برای ایجاد یک پنجره جدید استفاده می‌شود. در اینجا، پارامترهای مختلفی به آن ارسال شده است:

  • 0: این پارامتر برای تعیین ویژگی‌های اضافی پنجره است. در اینجا هیچ ویژگی اضافی مشخص نشده است.

  • CLASS_NAME: نام کلاسی که پنجره بر اساس آن ایجاد می‌شود. این باید با نام کلاسی که قبلاً با RegisterClass ثبت شده، مطابقت داشته باشد.

  • "Maze Project": عنوان پنجره که در نوار عنوان نمایش داده می‌شود.

  • WS_OVERLAPPEDWINDOW & ~WS_MAXIMIZEBOX: این ترکیب نوع پنجره را مشخص می‌کند. WS_OVERLAPPEDWINDOW نوعی از پنجره است که شامل نوار عنوان و نوار وضعیت می‌شود. با استفاده از & ~WS_MAXIMIZEBOX، گزینه حداکثر کردن پنجره غیرفعال شده است.

  • CW_USEDEFAULT: این مقادیر برای موقعیت و اندازه پنجره استفاده می‌شوند. CW_USEDEFAULT به معنای استفاده از مقادیر پیش‌فرض است.

  • NULL: این پارامتر برای تعیین والد پنجره است. در اینجا، پنجره والد مشخص نشده است.

  • hInstance: شناسه نمونه‌ای که برنامه اجرا شده است. این معمولاً به عنوان پارامتر ورودی به تابع WinMain ارسال می‌شود.

  • NULL: این پارامتر برای ارسال داده‌های اضافی به پنجره است، که در اینجا خالی است.

▎2. نمایش پنجره

ShowWindow(hwnd, nShowCmd);


• ShowWindow: این تابع برای نمایش پنجره ایجاد شده استفاده می‌شود.

  • hwnd: شناسه پنجره‌ای که باید نمایش داده شود.

  • nShowCmd: دستور نمایش (مانند SW_SHOW, SW_HIDE, و غیره) که تعیین می‌کند چگونه پنجره نمایش داده شود.

▎3. حلقه پیام

MSG msg;
while (GetMessage(&msg, NULL, 0, 0)) {
    TranslateMessage(&msg);
    DispatchMessage(&msg);
}


• MSG msg;: یک ساختار پیام برای ذخیره اطلاعات پیام‌ها.

• GetMessage(&msg, NULL, 0, 0): این تابع پیام‌ها را از صف پیام‌ها دریافت می‌کند. اگر پیام جدیدی وجود داشته باشد، آن را در msg ذخیره کرده و تابع مقدار TRUE برمی‌گرداند. اگر پیام WM_QUIT دریافت شود، مقدار FALSE برمی‌گرداند و حلقه متوقف می‌شود.

• TranslateMessage(&msg): این تابع پیام‌های کلید را ترجمه می‌کند (به عنوان مثال، تبدیل کلید فشرده شده به پیام‌های مربوط به آن).

• DispatchMessage(&msg): این تابع پیام را به تابع پردازش پیام (که معمولاً WindowProc یا مشابه آن است) ارسال می‌کند تا پردازش شود.

▎4. پایان برنامه

return 0;


• در نهایت، پس از خروج از حلقه پیام، تابع مقدار 0 را برمی‌گرداند که نشان‌دهنده پایان موفقیت‌آمیز برنامه است.

▎نتیجه‌گیری

این بخش از کد مسئول ایجاد و نمایش پنجره اصلی برنامه، مدیریت رویدادها و پیام‌های دریافتی از سیستم عامل است. با استفاده از این ساختار، برنامه قادر به تعامل با کاربر و پاسخگویی به رویدادهای مختلف مانند فشردن کلیدها و تغییر اندازه پنجره خواهد بود. اگر سوال خاصی دارید یا نیاز به توضیحات بیشتری دارید، لطفاً بفرمایید!
